
"""Knowledge_Graph_REBEL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fJImvlanOO1srD-U1-gmKmS-WIWIVKOr

# AgilAI - CPS Informatik
## Creating Knowledge Graph for Knowledge Base using Transformers - Â© TU Kaiserslautern
##### Khushnood Adil Rafique (MSc, MCA) (khushnood.rafique@cs.uni-kl.de),
##### Frank Wawrzik (MSc) (wawrzik@cs.uni-kl.de),
##### Vishwanath Tarikere Sathyanarayana(MSc) (sathyana@rhrk.uni-kl.de)
* In this thesis, we try to Implement a full pipeline that extracts relations from text, builds a knowledge graph, and visualizes it.
* The main idea is based on named entity recognition (NER) and relation classification
* The classes or labels are based on Ontology standard ISO 26262
* The model used here is a  Relation Extraction By End-to-end Language generation (REBEL).

##### What is Knowledge Base and Knowledge Graph?
A Knowledge Base (KB) is information stored as structured data, ready to be used for analysis or inference. Usually, a KB is stored as a graph (i.e. a Knowledge Graph), where nodes are entities and edges are relations between entities.


##### How REBEL works?
REBEL is a text2text model trained by BabelScape by fine-tuning BART for translating a raw input sentence containing entities and implicit relations into a set of triplets that explicitly refer to those relations. It has been trained on more than 200 different relation types.

##### Import all the necessary libraries and classes.
* Transformers: Load the REBEL mode.
* pyvis: Graphs visualizations.
"""



from transformers import AutoModelForSeq2SeqLM, AutoTokenizer
import math
import torch
import IPython
from pyvis.network import Network


"""#### Load Pickle File"""

import pickle
# relations.pkl file already contains the pre-extracted subject and object nodes for our sentences
kb = pickle.load(open("relations.pkl", "rb"))

nodes = []
for dp in kb:
    nodes.extend([dp["head"], dp["tail"]])

#getting the unique nodes from the extracted pickle file 
nodes = list(set(nodes))

tags = dict()

import pandas as pd
df = pd.read_csv("combined_data_v8.csv")

# labelling the node with Agiladb_tag
for node in nodes:
    try:
        tag = df[df.Word == node.split()[0]]["Agila_DB_tag"].value_counts().index[0]
        tags[node] = tag
    except:
        pass

# removing the "O" class nodes from the existing nodes and spliting the class value to get the class label
filtered_tags = dict()

for key, value in tags.items():
    if value != "O":
        filtered_tags[key] = value.split("-")[-1]

tag_nodes = list(filtered_tags.keys())

# still removing the relations where subject and object are same
filtered_kb = []
for dp in kb:
    f_kb = dict()
    if (dp["head"] in tag_nodes) and (dp["tail"] in tag_nodes):
        if dp["head"] != dp["tail"]:
            f_kb["head"] = dp["head"]
            f_kb["tail"] = dp["tail"]
            f_kb["type"] = dp["type"]
            filtered_kb.append(f_kb)

set(filtered_tags.values())

"""| Class I (Subject)| Realtion (Predicate) |Class II (Object) |
|:-----|:---------------|:---------------|
|system | has part directly |component|
|hardware component| has part directly | hardware part |
|element (here: component, <br> hardware component <br> harware part <br> hardware subpart <br> software <br> system) | implements |function |
|processing unit| executes | software |
|hardware subpart| part of directly | hardware part |
|element (here: component, <br> hardware component <br> harware part <br> hardware subpart <br> software <br> system)|has property|quantity |
|quantity| has value | measure |
|measure| has unit | unit |
"""

# forming relations between the nodes
def get_newKB(kb, tags):
    new_kb = []
    for dp in kb:
        d_ = dict()
        d_["head"] = dp["head"]
        d_["tail"] = dp["tail"]
        
        if tags[dp["head"]] == "sys" and tags[dp["tail"]] == "comp":
            d_["type"] = "has part directly"
            if d_ not in new_kb:
                new_kb.append(d_)
        elif  tags[dp["head"]] == "comp" and tags[dp["tail"]] == "sys":
            d_["type"] = "direct part of"
            if d_ not in new_kb:
                new_kb.append(d_)
            
        elif  tags[dp["head"]] == "hwc" and tags[dp["tail"]] == "hwp":
            d_["type"] = "has part directly"
            if d_ not in new_kb:
                new_kb.append(d_)
        elif  tags[dp["head"]] == "hwp" and tags[dp["tail"]] == "hwc":
            d_["type"] = "direct part of"
            if d_ not in new_kb:
                new_kb.append(d_)
            
        elif  tags[dp["head"]] not in ["mea", "qt", "unit","func"] and tags[dp["tail"]] == "func":
            d_["type"] = "implements"
            if d_ not in new_kb:
                new_kb.append(d_)
        elif  tags[dp["head"]] == "func" and tags[dp["tail"]] not in ["mea", "qt", "unit"]:
            d_["type"] = "implemented by"
            if d_ not in new_kb:
                new_kb.append(d_)
            
        elif  tags[dp["head"]] in ["sys", "comp", "hwc", "hwp", "hwsp"] and tags[dp["tail"]] == "sw":
            d_["type"] = "executes"
            if d_ not in new_kb:
                new_kb.append(d_)
        elif  tags[dp["head"]] == "sw" and tags[dp["tail"]] in ["sys", "comp", "hwc", "hwp", "hwsp"]:
            d_["type"] = "executed by"
            if d_ not in new_kb:
                new_kb.append(d_)
            
        elif  tags[dp["head"]] == "hwsp" and tags[dp["tail"]] == "hwp":
            d_["type"] = "part of directly"
            if d_ not in new_kb:
                new_kb.append(d_)
        elif  tags[dp["head"]] == "hwp" and tags[dp["tail"]] == "hwsp":
            d_["type"] = "has part"
            if d_ not in new_kb:
                new_kb.append(d_)
        
        elif  tags[dp["head"]] not in ["mea", "func", "unit", "qt"] and tags[dp["tail"]] == "qt":
            d_["type"] = "has property"
            if d_ not in new_kb:
                new_kb.append(d_)
        elif  tags[dp["head"]] == "func" and tags[dp["tail"]] not in ["mea", "func", "unit", "qt"]:
            d_["type"] = "property of"
            if d_ not in new_kb:
                new_kb.append(d_)
            
        elif  tags[dp["head"]] == "qt" and tags[dp["tail"]] == "mea":
            d_["type"] = "has value"
            if d_ not in new_kb:
                new_kb.append(d_)
        elif  tags[dp["head"]] == "mea" and tags[dp["tail"]] == "qt":
            d_["type"] = "value of"
            if d_ not in new_kb:
                new_kb.append(d_)
            
        elif  tags[dp["head"]] == "mea" and tags[dp["tail"]] == "unit":
            d_["type"] = "has unit"
            if d_ not in new_kb:
                new_kb.append(d_)
        elif  tags[dp["head"]] == "unit" and tags[dp["tail"]] == "mea":
            d_["type"] = "unit of"
            if d_ not in new_kb:
                new_kb.append(d_)
            
    return new_kb

new_kb = get_newKB(filtered_kb, filtered_tags)

nodes = []
for r in new_kb:
    nodes.extend([r["head"], r["tail"]])

#unique nodes to plot in the knowledge base
nodes = list(set(nodes))

"""##### Pyvis Network
Visualize the output of our work by plotting the knowledge bases. As our knowledge bases are graphs, we can use the pyvis library, which allows the creation of interactive network visualizations.

We define a save_network_html function that:

* Initialize an empty directed pyvis network.
* Add the knowledge base entities as nodes.
* Add the knowledge base relations as edges.
* Save the network in an HTML file.
"""

import IPython
from pyvis.network import Network
def save_network_html(kb, nodes):
    # create network
    net = Network(directed=True, width="1500px", height="900px", bgcolor="#eeeeee")

    # nodes
    color_entity = "#00FF00"
    for e in nodes:
        net.add_node(e, shape="circle", color=color_entity)

    # edges
    for r in kb:
        net.add_edge(r["head"], r["tail"],
                    title=r["type"], label=r["type"])
        
    # save network
    net.repulsion(
        node_distance=200,
        central_gravity=0.2,
        spring_length=200,
        spring_strength=0.05,
        damping=0.09
    )
    net.set_edge_smooth('dynamic')
    net.show("file.html")

#returns the knowledge base graph
save_network_html(new_kb, nodes)

from IPython.display import IFrame

IFrame(src='./file.html', width=1000, height=600)

